use alloc::{
    collections::btree_map::BTreeMap as HashMap,
    ffi::CString,
    string::{String, ToString},
    vec::Vec,
};
use goblin::{
    elf::{Elf, Reloc},
    elf64::sym::{STB_GLOBAL, STT_FUNC, STT_OBJECT, STT_SECTION},
};
use log::debug;

use crate::{
    common::{get_section_bytes, round_section_length, Symbol, LDDW_OPCODE},
    femtocontainer_relocations::{FC_LDDWD_OPCODE, FC_LDDWR_OPCODE},
    model::{Lddw, RelocatedCall},
};

/// The binary generated after the relocation script has the following format:
/// - Header: Contains the information about the lengths of the remaining sections
///   functions and read-only data. See [`Header`] for more details
/// - Data section
/// - Read-only data section
/// - Text section: Contains the code of the main entrypoint and the other functions
/// - Symbol structs: TODO: figure out why we need this
/// - Relocated function calls: custom metadata specifying how function calls should be relocated
struct Binary {
    header: Header,
    data: Vec<u8>,
    rodata: Vec<u8>,
    text: Vec<u8>,
    functions: Vec<Symbol>,
    relocated_calls: Vec<RelocatedCall>,
}

pub const HEADER_SIZE: usize = 28;
impl Into<Vec<u8>> for Binary {
    fn into(self) -> Vec<u8> {
        let header_bytes = unsafe {
            alloc::slice::from_raw_parts(&self.header as *const _ as *const u8, HEADER_SIZE)
        };
        let mut binary = Vec::from(header_bytes);
        binary.extend(self.data);
        binary.extend(self.rodata);
        binary.extend(self.text);

        // For some reason this function symbol metadata is appended at the
        // end of the binary in the FC implementation, however their version
        // of the VM doesn't use any of that information.
        for symbol in self.functions {
            let symbol: &[u8] = (&symbol).into();
            binary.extend(symbol);
        }

        for call in self.relocated_calls {
            let call: &[u8] = (&call).into();
            binary.extend(call);
        }

        binary
    }
}

/// A header that is appended at the start of the generated binary. Contains
/// information about the length of the correspoinding sections in the binary
/// so that the VM executing the code can access the .rodata and .data sections
/// properly.
#[repr(C, packed)]
pub struct Header {
    magic: u32,
    version: u32,
    flags: u32,
    data_len: u32,
    rodata_len: u32,
    text_len: u32,
    functions_len: u32,
}

/// Applies ahead-of-time modifications to the binary to so that it can be
/// executed on the target microcontroller device without resolving the
/// relocations.
///
/// Responsible for transforming the raw ELF files generated by llc into the
/// custom format which allows for handling a subset of the relocations (.rodata,
/// .data and function calls) without having to resolve relocations after loading
/// the program into memory on the target microcontroller device.
///
/// It is backwards compatible with the bytecode patching workflow used by Femto
/// -Containers. This means that programs produced by this script should still
/// be executable on default version of the Femto-Container eBPF VM.
pub fn assemble_binary(program: &[u8]) -> Result<Vec<u8>, String> {
    let Ok(binary) = goblin::elf::Elf::parse(&program) else {
        return Err("Failed to parse the ELF binary".to_string());
    };

    // First extract the bytes contained in all three main sections
    let mut text: Vec<u8> = get_section_bytes(".text", &binary, &program);
    let mut data: Vec<u8> = get_section_bytes(".data", &binary, &program);
    let mut rodata: Vec<u8> = get_section_bytes(".rodata", &binary, &program);

    // Now handle all string literals that aren't placed in .rodata
    // section by default. We need to append them to the .rodata section
    // and maintain the information about the offsets at which they are
    // stored so that we can relocate loads from them later on.
    let str_section_offsets = append_string_literals(&mut rodata, &binary, &program);

    // Now we need to collect all global functions and append their names
    // to the rodata section. We also need to maintain the information
    // about the offsets at which the function names are stored.
    // This is maintained for compatibility with the rbpf bytecode patching
    // script. It isn't actually used by their VM.
    let symbol_structs: Vec<Symbol> = extract_function_symbols(&mut rodata, &binary);

    let relocated_calls: Vec<RelocatedCall> = find_relocated_calls(&binary, &program);

    resolve_rodata_relocations(&mut text, &binary, &program, &str_section_offsets);

    round_section_length(&mut data);
    round_section_length(&mut rodata);

    // Now we write the new binary file
    let header = Header {
        magic: 123,
        version: 0,
        flags: 0,
        data_len: data.len() as u32,
        rodata_len: rodata.len() as u32,
        text_len: text.len() as u32,
        functions_len: symbol_structs.len() as u32,
    };

    let output_binary: Binary = Binary {
        header,
        data,
        rodata,
        text,
        functions: symbol_structs,
        relocated_calls,
    };

    Ok(output_binary.into())
}

/// String literals used in e.g. calls to printf are loaded into the
/// .rodata.str.1 section, we need to move them over to the rodata section.
/// In order to perform relocations properly later on, we need to maintain
/// the map from the name of the additional rodata section to the offset
/// to it relative to the original rodata section. This map is returned from this
/// functio.
fn append_string_literals<'a>(
    rodata: &mut Vec<u8>,
    binary: &Elf<'a>,
    buffer: &[u8],
) -> HashMap<&'a str, usize> {
    let mut str_section_offsets = HashMap::new();

    for section in &binary.section_headers {
        if let Some(section_name) = binary.strtab.get_at(section.sh_name) {
            // The string literals are stored in the .rodata.str.1 section
            if section_name.contains(".rodata.") {
                str_section_offsets.insert(section_name, rodata.len());
                rodata.extend(
                    &buffer[section.sh_offset as usize
                        ..(section.sh_offset + section.sh_size) as usize],
                );
            }
        }
    }

    debug!(
        "Additional read-only string sections: {:?}",
        str_section_offsets
    );

    str_section_offsets
}

fn extract_function_symbols(rodata: &mut Vec<u8>, binary: &Elf<'_>) -> Vec<Symbol> {
    let mut symbol_structs: Vec<Symbol> = alloc::vec![];
    for symbol in binary.syms.iter() {
        if symbol.st_type() == STT_FUNC && symbol.st_bind() == STB_GLOBAL {
            let symbol_name = binary.strtab.get_at(symbol.st_name).unwrap();

            debug!("Found global function: {}", symbol_name);
            let offset_within_text = symbol.st_value as usize;
            let offset = rodata.len();
            let name_cstr = CString::new(symbol_name).unwrap();
            rodata.extend(name_cstr.to_bytes().iter());
            // Added flags for compatiblity with rbpf
            let flags = 0;
            symbol_structs.push(Symbol {
                name_offset: offset as u16,
                flags: flags as u16,
                location_offset: offset_within_text as u16,
            });
        }
    }
    symbol_structs
}

fn find_relocated_calls(binary: &Elf<'_>, buffer: &[u8]) -> Vec<RelocatedCall> {
    let mut relocated_calls: Vec<RelocatedCall> = alloc::vec![];
    let relocations = find_relocations(binary, buffer);
    for reloc in relocations {
        debug!("Relocation found : {:?}", reloc);
        if let Some(symbol) = binary.syms.get(reloc.r_sym) {
            if symbol.st_type() == STT_FUNC {
                let name = binary.strtab.get_at(symbol.st_name).unwrap();
                debug!(
                    "Relocation at instruction {} for function {} at {}",
                    reloc.r_offset, name, symbol.st_value
                );
                relocated_calls.push(RelocatedCall {
                    instruction_offset: reloc.r_offset as u32,
                    function_text_offset: symbol.st_value as u32,
                });
            }
        }
    }
    relocated_calls
}

/// Responsible for handling relocations for the read-only data used by the program.
/// It works by introducing two custom load-double-word (LDDW) instructions (
/// see [`Lddw`]) that indicate that the particular load instruction is supposed
/// to target the .rodata or .data section. This is coupled with the implementation
/// of the VM and not compatible with the default eBPF standard.
fn resolve_rodata_relocations(
    text: &mut Vec<u8>,
    binary: &Elf<'_>,
    buffer: &[u8],
    str_section_offsets: &HashMap<&str, usize>,
) {
    let relocations = find_relocations(binary, buffer);
    for relocation in relocations {
        if let Some(symbol) = binary.syms.get(relocation.r_sym) {
            let section = binary.section_headers.get(symbol.st_shndx).unwrap();
            let section_name = binary.strtab.get_at(section.sh_name).unwrap();
            match symbol.st_type() {
                STT_SECTION => {
                    debug!(
                        "Relocation at instruction {} for section {} at {}",
                        relocation.r_offset, section_name, symbol.st_value
                    )
                }
                STT_FUNC => continue, // We don't patch for functions
                _ => {
                    let symbol_name = binary.strtab.get_at(symbol.st_name).unwrap();
                    debug!(
                        "Relocation at instruction {} for symbol {} in {} at {}",
                        relocation.r_offset, symbol_name, section_name, symbol.st_value
                    )
                }
            }
        }

        patch_text(text, binary, relocation, &str_section_offsets);
    }
}

fn find_relocations(binary: &Elf<'_>, buffer: &[u8]) -> Vec<Reloc> {
    let mut relocations = alloc::vec![];
    let context = goblin::container::Ctx::default();
    debug!("Relocation parsing context: {:?}", context);
    for section in &binary.section_headers {
        if section.sh_type == goblin::elf::section_header::SHT_REL {
            let offset = section.sh_offset as usize;
            let size = section.sh_size as usize;
            let relocs =
                goblin::elf::reloc::RelocSection::parse(&buffer, offset, size, false, context)
                    .unwrap();
            relocs.iter().for_each(|reloc| relocations.push(reloc));
        }
    }

    relocations
}

fn patch_text(
    text: &mut [u8],
    binary: &Elf<'_>,
    reloc: Reloc,
    str_section_offsets: &HashMap<&str, usize>,
) {
    debug!("Patching text for relocation symbol: {:?}", reloc);
    let symbol = binary.syms.get(reloc.r_sym).unwrap();
    let section = binary.section_headers.get(symbol.st_shndx).unwrap();
    let section_name = binary.strtab.get_at(section.sh_name).unwrap();
    let mut offset = 0;

    // We don't do eny relocations in case of functions as they are handled
    // in a custom way by the VM (we append their relocation structs at the end of the binary
    // file)
    if symbol.st_type() == STT_FUNC {
        debug!("No patching is performed for function calls.");
        return;
    }

    if symbol.st_type() == STT_SECTION {
        if let Some(off) = str_section_offsets.get(section_name) {
            offset = *off;
        } else {
            debug!("No offset found for section: {}", section_name);
            return;
        }
    } else if symbol.st_type() == STT_OBJECT {
        offset = symbol.st_value as usize;
    }

    // We only patch LDDW instructions
    if text[reloc.r_offset as usize] != LDDW_OPCODE as u8 {
        debug!("No LDDW instruction at {}", reloc.r_offset);
        return;
    }

    let opcode = if section_name.contains(".rodata.str") {
        FC_LDDWD_OPCODE
    } else {
        FC_LDDWR_OPCODE
    };

    // We instantiate the instruction struct to modify it
    let instr_bytes = &text[reloc.r_offset as usize..reloc.r_offset as usize + 16];
    debug!(
        "Replacing {:?} at {} with {} at {}",
        instr_bytes, reloc.r_offset, opcode, reloc.r_offset
    );

    let mut instr: Lddw = Lddw::from(instr_bytes);
    instr.opcode = opcode as u8;
    instr.immediate_l += offset as u32;

    text[reloc.r_offset as usize..reloc.r_offset as usize + 16].copy_from_slice((&instr).into());
}
